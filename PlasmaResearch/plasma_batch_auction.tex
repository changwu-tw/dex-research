\documentclass[11pt,parskip=full]{scrartcl}%article}
%\setlength{\parskip}{1em}

%%%%%%%%%%%%%%%%%%%%%%
%% PACKAGE INCLUDES %%
%%%%%%%%%%%%%%%%%%%%%%

\usepackage{array}           % For defining \newcolumntype.
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}          % Provides 'proof' environment.
\usepackage[english]{babel}  % For defining 'theorem/corollary/lemma' environments.
\usepackage{bm}              % Provides bold \pi
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{gensymb}         % Enables \degree command for Â°C.
\usepackage{todonotes}
\usepackage{subfig}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{listings} % http://ctan.org/pkg/listings

\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\usepackage[toc,page]{appendix}

%%%%%%%%%%%%%%%%%
%% STYLE SETUP %%
%%%%%%%%%%%%%%%%%

% Define some custom colors.
\definecolor{mylinkcolor}{RGB}{000, 114, 166}
\definecolor{mycitecolor}{RGB}{255, 154, 071}
\definecolor{myurlcolor}{RGB}{000, 114, 166}

% Set itemize format.
\setitemize{noitemsep,topsep=-5pt,parsep=5pt,partopsep=0pt}

% Define column types that allow fixed width params.
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

% Color setup for hyperlinks/references/citations/urls.
\hypersetup{
    colorlinks,
    linkcolor={mylinkcolor},
    citecolor={mycitecolor},
    urlcolor={myurlcolor}
}

% Specify hyphenation of words on line break.
\hyphenation{Figure Table Chapter Section}

\long\def\/*#1*/{}



%%%%%%%%%%%%
%% MACROS %%
%%%%%%%%%%%%

% Set default font family to sans-serif.
\renewcommand*{\familydefault}{\sfdefault}
\newcommand{\Tau}{\mathrm{T}}

\newcommand*{\ie}{i.e., }
\newcommand*{\eg}{e.g., }
\newcommand*{\wrt}{w.r.t. }

\newcommand*{\tokens}{\mathcal{T}}          % Set of tokens.
\newcommand*{\orders}{\mathcal{O}}          % Set of orders.
\newcommand*{\itokens}{\mathcal{I}^t}       % Set of token indices.
\newcommand*{\itokenpairs}{\mathcal{I}^p}   % Set of token index pairs.
\newcommand*{\iorders}{\mathcal{I}^o}       % Set of order indices.
\newcommand*{\ibuyorders}{\mathcal{I}^b}    % Set of buy order indices.
\newcommand*{\isellorders}{\mathcal{I}^s}   % Set of sell order indices.

% Macros for references etc.
\newcommand*{\figref}[1]{\hyperref[{#1}]{Figure~\ref*{#1}}}
\newcommand*{\tabref}[1]{\hyperref[{#1}]{Table~\ref*{#1}}}
\newcommand*{\secref}[1]{\hyperref[{#1}]{Section~\ref*{#1}}}
\newcommand*{\subsecref}[1]{\hyperref[{#1}]{Section~\ref*{#1}}}
\newcommand*{\thmref}[1]{\hyperref[{#1}]{Theorem~\ref*{#1}}}
\newcommand*{\crlref}[1]{\hyperref[{#1}]{Corollary~\ref*{#1}}}
\newcommand*{\lemref}[1]{\hyperref[{#1}]{Lemma~\ref*{#1}}}

% Macros for theorems|corollaries|lemmas.
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

%Notational abbreviations

\def\pO{\mathcal{O}}
\def\ra{\rightarrow}

\newcommand*{\erc}{ERC20 }
%%%%%%%%%%%%%%
%% DOCUMENT %%
%%%%%%%%%%%%%%

\title{
  Multi-token Batch Auctions with Uniform Clearing Prices on Plasma\\
  - \\
  \Large Specification For Implementation}
\author{Gnosis}

\date{\today}



\begin{document}

\maketitle


\begin{abstract}

This document outlines a formal specification of a batch auction exchange of ERC20 tokens using the plasma technologies. 
The batch auction mechanism will enable the execution of ring trades between different tokens. 
Plasma technologies will provide - under some assumptions - the same security for users as if the tokens were held in the ethereum blockchain. 
But gas costs will be significantly reduced due to the off-chain nature of the exchange mechanism. 
It is recommended for the reader to familiarize themselves with Plasma\cite{plasma}, Plasma MVP\cite{MVP}, snarks\cite{snarks} and batch auctions\cite{batch} before reading this spec. 

\end{abstract}

\tableofcontents

\newpage
\section{Introduction}
\label{sec:introduction}

\paragraph{Multi-batch auctions with uniform clearing prices}

This specification outlines a trading mechanism between several \erc tokens. Each batch accepts orders to buy any \erc token with any other \erc token for a maximal specified limit price. All orders are collected over some time interval and then a \emph{uniform clearing price} over all token pairs is calculated. 

For a list of $n$ trading tokens denoted by $\Tau$ with clearing prices $\{p_{ij}\}$, we call the set of prices $\{p_{ij}| \tau_i, \tau_j \in \Tau\}$ an uniform clearing price, if
\begin{align} \label{arbitrage_free}
  p_{ij} \cdot p_{jk} &= p_{ik}\\
  p_{ij} &= p_{ji}^{-1}
\end{align}

These equations imply that there is no arbitrage opportunity between any of the n tokens.
Finding the uniform clearing prices, which also maximize trading volume or other predefined metrics is a complicated task. One possible mechanism is described in detail in \cite{priceOptimization}. Uniform clearing prices are beneficial for any trader since they are arbitrage-free and ensure good liquidity via built-in ring trades. For the purpose of this document, it is assumed that these uniform clearing prices for a multi-batch auction can be efficiently determined. \newline
The multi-token batch mechanism is secured against front-running \footnote{Front-running is when a actor enters into an equity/asset trade with foreknowledge of a transaction which will influence the price} by allowing users to submit encrypted orders into the batch auction. Only after the batch has closed the orders will be revealed and then the prices will be computed. 


\paragraph{Plasma minimal viable product}

This paper describes the specification for porting this auction mechanism onto a plasma chain \cite{plasma}. Plasma chains are a second layer scaling solution for blockchains which allow processing a much higher volume of transactions as the underlying blockchain (a.k.a. \emph{root-chain}) with the same security guarantees\footnote{The same security is actually only given under the assumptions that transactions are not censored on the root chain for a longer period of time, and the plasma clients stay online and validate the plasma chain frequently}. This is the main motivation for implementing such mechanism on a plasma chain as it will result in significantly less costs per trade. Unfortunately, plasma chains have also a disadvantages: They come with burdens in terms of complexity and sometimes usability. We are planning to use Ethereum as the root-chain. 

\paragraph{The trade-flow of a batch auction}  

The batch auction exchange is built on a plasma chain operated by a single entity on top of a root-chain. A single batch auction consists of several phases:
\begin{itemize}
\item[(i)] Encryption Key Generation, 
\item[(ii)] Order Collection, 
\item[(iii)] Double Signing, 
\item[(iv)] Decryption Key Generation,
\item[(v)] Batch Price Calculation,
\item[(vi)] Batch Challenging and 
\item[(vii)] Order Executions. 

\end{itemize}
In brief, a batch will proceed as follows: Users will post encrypted orders to the plasma operator, who will then bundle these orders and commit them by posting a single order-block on the plasma chain. Each client will have to validate the orders of this order-block. Only once they have validated the orders, they may double sign their orders to participate in the current batch. The participation acknowledgment will be compactly represented using a crypto-economic signature aggregation schema. With this construction many data-unavailability problems will be avoided because the orders can be represented on the root-chain using only a bitmap.
Once the bitmap is seen by many parties on the plasma chain, the private key for decrypting the orders will be generated using distributed key generation (DKG). Finally, all the data is available to calculate correct prices from the orders and the batch can be settled. 


\newpage

\section{Detailed specification overview}
\subsection{Setup description}

\subsubsection{Definitions}


%Let us start of with writing down some very basic definitions, which we will use throughout this paper.
In our batch auctions all trading will occur between a fixed set, $\Tau = \{\tau_i\}_{i=1}^n$, of $n$ \erc tokens. The collection of orders for which token $\tau_i$ is being sold in exchange for token $\tau_j$ will be denoted by $\pO_{i\ra j}$. 

After an auction has been closed and uniform clearing prices have been determined, the price matrix can be represented as an $n\times n$ matrix 
\[P = \{p_{ij}| \tau_i, \tau_j \in \Tau \}.\]
Due to the equation \ref{arbitrage_free}, it is enough to define the uniform clearing price as an one dimensional vector with respect to a reference token $\tau_i$:
\[ \vec{p}_i = \{p_{ij}| \tau_i \in \Tau \}.\]
The vector
\begin{equation}
\vec{p} =\{ p_{ij}| \tau_j \in \Tau \} \quad \text{with} \quad \tau_i =ETH
\label{pricevector}
\end{equation}
will be called the \emph{price vector} of an auction.\newline
For any order $\sigma \in \pO_{i\ra j}$ we define $\nu_p(\sigma)$ as the volume of an order denominated in token $\tau_i$ at clearing prices $p$.


\subsubsection{Plasma chain setup}
We are following the description of the Plasma Minimal Viable Product\cite{MVP}. 
This means all assets are represented in the plasma chain as unspent transaction outputs (utxo). 
These utxos can be transferred to a new owner by making a transaction, waiting for its inclusion into the plasma chain, validating the chain, waiting for the plasma block to be submitted to the root-chain and then, sending a double-sign message to the receiver. 

Any utxo may be exited at any time, by providing a Merkle proof of the receiving transaction and its double signing. 
However, if the exit is not valid, then it will be canceled via a challenge process.
The mvp also defines a \emph{exit-request-timeperiod}\label{exit-time}, which is usually set to 7 days. The plasma mvp requires people to be online and validate the chain frequently.
The time difference between two consecutive validations should not be bigger than exit-request-timeperiod.


\subsection{The trade flow}
\label{subsec:data}

In the following section we will describe the general trade-flow for the batch auction through all its phases.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{overview_tradeflow.png}
\end{figure}



\subsubsection{DKG: Encryption Key Generation}
All orders will be encrypted with a public key generated by the Distributed Key Generation (DKG) algorithm \cite{DKG}. 
A predefined number of bonded participants will be part of the DKG algorithm. 
By exchanging special messages and withholding others, they will generate a new public key for which the private decryption key is not known to any single participant. 
Only later, after the auction closes, in a second step the DKG participants are requested to publish their private messages for the generation of the private key for the decryption of the orders.
If a predefined threshold of participants publish it, this will allow anyone to generate the private key. 
If the participants publish their messages previous to the closing of the batch and its documentation on the root-chain, the protocol will allow to slash them. 
With this approach, we have encrypted yet binding orders, unless a large portion of bonded DKG participants are malicious. 

Only if not enough DKG participants reveal their private information and the threshold is not reached, we have to revert the last auction (cp. \ref{enforceAvailablity}).


The public key generated by the DKG procedure can then be used to encrypt messages via the ECIES \cite{ECIES}. 
The ECIES design for our purpose is described in the appendix \ref{ECIES}.


\subsubsection{Order Collection}
\label{orderblock}
Once the public key for the encryption process is available, every trader can submit orders. 
In the plasma chain, all assets of the ERC20 tokens are represented by unspent transaction outputs (utxo). 
An order $\pO_{i\ra j}$ will refer to a utxo of an \erc token $\tau_i$ and this utxo will be exchanged for the specified target token $\tau_j$ for a price below the given limit price. The target token and the limit price will be encrypted.

\begin{verbatim}
Order [ utxo,
    Encry(Token j),
    Encry(LimitPrice),
    EncryptionSalt,
    Signatures]
\end{verbatim} 
The encryption salt is an elliptic point used for encryption (cp. \ref{salt}). 
All orders will be collected and boardcast in one block per auction, the \emph{order-block}. 
All orders included in this order-block will be able to participate in the next auction. 
Theoretically, the plasma operator could censor orders, but since they are encrypted, no meaningful information could be obtained.
However, due to storage constraints (i.e. no more than $2^{16}$ orders per auction), the operator would be required to monitor the number of orders at any given time.
If there are a lot of orders placed the operator will charge a small fee for each order placement via a separate state channel. 
In the case that a participant seeks to cancel their order, they can notify the plasma operator or simply do not double sign their order. 

\subsubsection{Double Signing}
Once the order-block is published and its Merkleroot hash is submitted to the root-chain, every participant in the batch auction must validate the current state of the system. 
Once they commit that their order should be included in the next batch, they will be able to withdraw their order funds only with the priority\footnote{The priority-queue is an important concept in the plasma MVP} of this order-block - this will be explained in detail here: \ref{exitRules}.

If participants validated the whole chain, they can send the operator the double signing message to signal their desire to participate. 
\begin{verbatim}
DoubleSign [OrderHash, OrderbookBlockHash, BatchIndex, Signature]
\end{verbatim}

The operator collects all these DoubleSign messages and constructs a \emph{bitmap}, in order to generate a crypto-economic signature aggregation (cp.\cite{sig}). 
The $i^{th}$ bit of this map is equal to 1 if the operator receives a DoubleSign message for the $i^{th}$ order, and is 0 otherwise.
The operator then publishes this bitmap along with all DoubleSign messages in a next plasma block. We will refer to this block as the \emph{confirmation-block}.\newline
In the event that the bitmap is unavailable or incorrect, anyone may request the operator to publish it on the root-chain.
Then each bit of the map could be challenged by asking the anyone to show the DoubleSign message and its Merkle-proof. 
In case the challenge is successful, we will revert the auction belonging to the challenge (cp. \ref{exitRules})


It is clear that the process of double signing will hinder the user experience (since users would have to remain online for the duration of the auction an then act again). 
However, the possibility of granting allowance to a third-party service could be available if desired.
This would, of course, involve some level of trust in the service, but this would be limited, as this service would not be capable of altering an order. That is to say, the service would only be granted permission to double sign.

\subsubsection{DKG: Private Key Generation}
Once the plasma block, containing the bitmap is published and submitted to the root-chain, the DKG participants will publish their hidden messages used for generating the DKG-public key. 
Once the threshold for the private key generation is reached and there are enough messages available to generate it, the private key will be broadcast to all participants by the chain operator.
\subsubsection{Auction Result Publication}
\subsubsection*{Price Determination}
Upon publication of the batch auction's private key, the operator will proceed in trying to find of the optimal price-matrix between all \erc tokens from the current batch of orders. 
While trying to find the optimal solution, he will also iteratively calculate the lower and upper bounds for the solutions. Once the difference between the upper and lower bounds is smaller than a predefined threshold, the plasma operator will stop the calculation and publish the uniform cleaning prices.\newline
As stated in before, the uniform clearing prices can be specified via a price vector \ref{pricevector}:
\begin{equation}
\vec{p}=\{ p_{ij}| \tau_j \in \Tau \} \quad \text{with} \quad \tau_i =ETH
\end{equation}

\/* 
\begin{lemma}
Any price matrix $P = [p_{ij}]$ subject to the constraint \ref{arbitrage_freeness} of arbitrage-freeness is enjoys the following properties;
\begin{itemize}
\item[(i)] $P$ is multiplicatively-symmetric\footnote{i.e. $P^\dagger = \frac{1}{P}$ where $P^\dagger$ denotes the point-wise transpose}. Equivalently, this the result of equation \ref{symmetric_pricing}.
\item[(ii)] The diagonal of $P$ consists entirely of 1's.
\item[(iii)]  $P$ is uniquely determined by its super-diagonal entries $\{p_{i, i+1}\}_{i=1}^{n-1}$.
\end{itemize}
\end{lemma}
*/
Along with this price vector, the operator would also generate for a batch a list of tuples representing order-volume pairs, 
\[[(\sigma_1, \nu_1), (\sigma_2,  \nu_2), \dots, (\sigma_N, \nu_N)]\]
where $(\sigma_i, \nu_i)$ denotes the $i^{th}$ order along with the volume $\nu_i$ of fulfilment and $N$ is the number of orders in the batch. 
This list will be referred to as the \emph{volume-list}\label{volumeBlock} and the lists Merkle hash will be the \emph{volume-hash}.

There is no guarantee that every order with a limit price below the uniform clearing price will be completely executed. Hence, the trading volume must be specified for each order.
This may come across as non-intuitive but does occur in batch auction trading.

\subsubsection*{3rd Party Price Submission [Optional]}
\label{publicPrices}
In the simplest implementation, the chain operator will always provide the prices. But this requires some faith in the plasma operator, as there is no guarantee that the final prices are optimal, i.e. that they really optimize a predefined traders welfare metric.
A little bit more advanced implementation could also accept price submission on the root-chain by any person. 
The smart contract on the root-chain would select the price submission as the final price, which is valid, has a snark valid proof of correctness and fairness and has the best score with respect to the predefined metric. Of course, we would need to modify the snark proofs a little, since they would also be required to prove the score in the trader's welfare metric. 

In this case, the price submitter would also need to provide the volume-list (cp. \ref{volumeBlock}) or at least assist traders with their exits games, by providing the Merkle proofs for their trading volumes (cp. \ref{exitRules}). 

\subsubsection*{Proof of Correctness and Fairness}
\label{proofprices}
Once the prices are calculated by the plasma operator, he needs to prove that this set of prices is actually valid and fair. A price set and a volume-list \ref{volumeBlock} is valid and fair, if

\begin{enumerate}

\item the price set is arbitrage free (cp. \ref{arbitrage_free} )
\item Orders have only a positive volume, if the orders are valid. Submitted orders can be invalid, if the specified encrypted target token is no in the list of traded tokens.
\item Orders are only touched, if the limit price is below the calculated price:\newline
\begin{equation} \forall \tau_i ,\tau_j \in \Tau \quad \forall \sigma \in \pO_{i\ra j}, \quad \nu_{p_{ij}}(\sigma)>0 \Rightarrow p_{ij}\geq \text{p}(\sigma)
\label{limitprice_sat}
\end{equation}
\item the amount of sell volume for a token equals its buy volume: 
\begin{equation}
\begin{split}
\forall \tau_i \in \Tau \quad \sum_{\tau_j\in \Tau} \,
\sum_{ \sigma\in \pO_{i \rightarrow j}} \nu_{p_{ij}}(\sigma) = \sum_{\tau_j\in \Tau} \, \sum_{\sigma\in \pO_{j\rightarrow i}} \frac{\nu_{p_{ji}}(\sigma)}{p_{ji}}
\label{volume_balance}
\end{split}
\end{equation}
\item If an order $\sigma \in \pO_{i\rightarrow j}$ with a limit price p has a positive trading volume, then every order in $\pO_{i\rightarrow j}$ with a lower limit price should be completely fulfilled. 
\end{enumerate}


In order to prove this, we will use snarks (succinct non-interactive arguments of knowledge) \cite{snarks}. 
In brief, snarks are a powerful tool enabling us to encode the above mentioned check-logic as an algebraical formulation. 
This allows us to generate some verification keys, which compactify this checking logic. 
Then for each set of prices and any volume-block, one can quickly generate a proof that the above constraints are satisfied using verification keys. 
The proof size is very small (8 variables of type bytes64) and can easily be provided to the root-chain. 
It turns out that the execution of such a proof would cost approximately 1.6 million gas on the root-chain. 
The library ZoKrates \cite{zokrates} demonstrates these methods very well within the ethereum eco-system. 
The details of these snark proofs are described in the appendix \ref{snarkElaboration}.


Once the operator has the price vector $\vec{p}$, the volume-list and the proof is calculated, all these information will be published in one \emph{auction-result-block}. The plasma operator will publish this block on the plasma chain. 


\subsubsection{Enforcing Key Variable Publication}

\label{enforceAvailablity}
In case the operator goes off-line and we get a data-unavailability, we still want to make sure that the last auction can be completed by all participants or it will be cleanly un-rolled. 
Since data-availability on the plasma chain is subjective, we need to make sure that all necessary information will be loaded into the root-chain, in the worst case. \newline
For loading either the bitmap, price vector, volume-hash or proofs in the root-chain we have the following procedure:
\begin{enumerate}
\item By default we publish the data only in the plasma chain
\item If a user does not see any of the data, he can send a request to publish the data on the root-chain. This request requires some additional fee, which cover the gas costs to answer the request.
\item Then anyone has the chance to answer the request together with a valid Merkle proof, which ensures that the answer is the same as given on Plasma chain. It is enough if the data is only published as payload, the data does not need to be stored completely on the root-chain. The answerer will be compensated with the fee from the requester.
\item If any request are not answered within a predefined time $\text{time}_\text{data-request}$, then the auction referred in the data request will be reverted.
This means that only utxos, which were submitted before the order-block of the reverted auction, will be accepted for any withdraw (cp. \ref{exitRules}). 
\end{enumerate}

For the following data, we will use this procedure.
\begin{enumerate}
\item \emph{bitmap}:
It is essential for everyone to know, what the bitmap of an auction is, in order to know which orders are in the batch. Since the order-block will contain 2**16 orders, the bitmap size will be $2^{16}$ bits. 


\item \emph{decryption keys}:
Also, the decryption key of an auction is essential to know, in order to see the limit prices of the encrypted orders. 
The size of the private key for decrypting the orders would be 2x $32$ bytes.

\item \emph{prices}:
The prices are also essential to know for each participant. 
If they are not public, again they can be made public with the same mechanism. 
We note that the gas costs for publishing the prices increase linearly with the number of tokens.

\item \emph{price verification}:
The proof of the correctness including the volumes-hash is initially only stored in the plasma chain. 
But anyone can request to publish the proof and the volume-block hash also on the root-chain. 
We use again the same mechanism as before. 
\end{enumerate}

\subsubsection{Order-output Transactions}
After the auction-result-block is published, the operator will publish another block with all order-output transactions. 
An order-output transaction for an order within $\pO_{i\ra j}$ will have the following format:

\begin{lstlisting}
OrderOutput [ Order txHash,
    Order output denominated in Token j ($oo_j$), 
    Token j,
    newOwner,
    Order output denominated in Token $\tau_i$ ($oo_i$),
    Token i,
    orderCreator]

\end{lstlisting}
The first order output denomiated in token $\tau_j$ is the trade output, which a trader gets for his input via the trade. 
The second order output equals the input of an order, if the order has not been touched or it handles potential left overs of a partial match.
The order-output ($oo_j$) denominated in Token $\tau_j$ will be calculated by the price 
\begin{equation}
  oo_j = p_{ij} \times \text{OrderInputAmount} \times \nu(\text{order}) 
    \label{fee_equ}
\end{equation}
where $\nu(\text{order})$ is the volume declared in the volume-list.  
Whereas, the order-output ($oo_i$) denominated in Token $\tau_i$ is defined by:
\begin{equation}
  oo_i =  \text{OrderInputAmount}\times (1 - \nu(\text{order}))
\end{equation}
These order-outputs can then be spent again via a transaction, but cannot be used as an input for another order. 
If any of these order-outputs is not correctly created by the plasma operator, people have to leave the plasma chain. 
Then the last batch will be settled on the root-chain or be reverted, depending on the availability of auction-result-block (cp. \ref{enforceAvailablity}). 



\subsubsection{Auction scheduling process}

An auction can have a variable timing. 
The operator can decide on his own when to close the batch and create the order-block \ref{orderblock}. 
Once this block is posted, it will take some time until the orders are processed. 
The operator will ensure a smooth flow by accepting new orders right away. 
However, these orders and all transfers could be reverted, if the chain will halt. 
Hence batch auctions can be scheduled pretty fast and smooth one after the other. 
However, the finality of an auction is only guaranteed after the client sees the auction-result-block, since with the knowledge of this block, they can answer all data-requests on the root-chain and thereby ensuring the finalization of the batch.

\subsection{Exit rules of the plasma chain}
\label{exitRules}
\paragraph{Transfer transactions} have quite the same exit rules, as in the usual plasma mvp. 
But there are two differences.
\begin{itemize}

 \item We would maintain a variable \emph{highestExitPriority}. 
This highestExitPriority would be infinity in normal cases. 
But if the plasma chain is halted, because a data-unavailability request (cp. \ref{enforceAvailablity}) was not answered in a certain time frame, then this variable will play an important role. 
It will set the highest exit priority to the priority of the last block, before the order-block submission. 
Any utxo generated after highestExitPriority will not be exitable and any exit request cannot be challenged with a utxo spend after this highestExitPriority. 
Effectively, we are resetting the plasma state to a previous state by setting highestExitPriority. 
\item Any utxo can be challenged as spent and not exit-able, by showing an order, a double signing of the order. Of course the Merkle proofs for this data needs to be provided.

\end{itemize}

\paragraph{Order transactions} can also be referenced for an exit request. The request are put into the same priority queue as the normal exits. They need to prove that
\begin{enumerate}
\item the order was included in the plasma chain by providing a Merkle proof
\item the order was double signed, by providing the bitmap and its merkle proof.
\item the trading volume of the batch auction by a Merkle proof with the volume-hash as root hash.
\end{enumerate}
For a "touched" order in $\pO_{i\ra j}$ only the target token $\tau_j$ can be withdrawn, but not the input token $\tau_i$. 
Hence, trades are enforced and cannot be reverted arbitrarily. 

If a data-unavailability appears right after the closing the batch, the order-output transaction might be already in a plasma block. 
These order-outputs cannot be used to challenge an order exit. 
Only if the order-output is already spent and double signed, then the order exit process can be challenged successfully. 

It might happen that a trader does not know the trading volume of his order in the last batch auction because neither the auction-result-block nor the order-output block might be unavailable for him. 
Then, he would not be able to provide the Merkle proof to attest his positive trading volume. 
In this case, we would ask on anyone to complete his exit, by providing the Merkle proof with the trading volume. 
If neither the plasma operator nor anyone else does answer this exit request within a predefined timeperiod $\text{time}_\text{data-request-time}$, then the auction will be stopped and all trades will be reverted, if the auction was conducted in the exit-request-timeperiod (cp. \ref{exit-time}). If the auction was not conducted in the exit-request-timeperiod, then the exit requester would have the data available.

Order withdrawals can be challenged by showing providing a double signed transfer of the order-output in the plasma chain. This is enough, since we do not allow orders to reference to other orders as a trade input.

\newpage

\section{Features}

\subsection{Trade enforcement}
Trades on this exchange will usually be enforced. 
That is, if an order was submitted, double signed and was touched by auction price, then the actor can only withdraw the trade-output nominated in the target token. 
But the trader will not get back his trade input. 

Unfortunately, some actors have an advantage.
If many DKG key holders do not reveal the decryption key, they can stop the chain. 
The DKG algorithm works with a predefined threshold. 
Only if more DKG participants as specified by the algorithm do not reveal their private input, then the batch cannot be executed. 
But in this case, we could also slash these DKG participants, which are misbehaving. 

\subsection{Safety in case of a data-unavailability}
For token transfers, we have the same data-unavailability fallbacks, as the MVP product. 
Hence a double sign mechanism protects people from losing funds. 
It is only getting a little bit more complex, as users should not double sign a transaction, which happens right after the closing of a batch.
Only after they validated the whole process of the batch closing, including the publishing of valid prices, snark proofs of correctness and a correct order-output block, they should . \newline
Also for traders, the safety is guaranteed by a  double signing mechanism. 
If there is anything incorrect, before the double signing step, traders will just not double sign their batch. 
If any network attack happens right after the order-block, the traders withdrawal priority of their order-output will be determined by the order-block. Hence, their priority will still be higher than any withdrawal request of this attack. This ensures that traders will always get their funds back or they can settle the last batch via the on chain exit. 
If there is any data not available for settling the trade with an exit request after the double signing step, then this data can be requested to be uploaded to the root-chain. 
The exchange is constructed in such a way with snarks and bitmaps, that it is easy and relatively cheap to publish this data on the root-chain. 
If the data is published, any trader can get his trade settled on chain. If the data is not published, the batch is reverted. 
For a detailed description of the data, which needs to be made available, see here: \ref{enforceAvailablity}. 
The proof that this data is enough to settle the trade either on the plasma chain or on the root-chain is left to the reader. 

\subsection{Non-custody of funds}
From the above analysis, we can conclude that the plasma plasma operator does never have the ability to steal tokens if all users come online regularly and behave correctly. 
This is one of the key features of this construction. 

\subsection{Grieving vectors and tragedy of the common}
Unfortunately, our specification had to take some trade-offs. 
The main problem is that data-unavailability is subjective. 
Hence, people can always claim that data is missing. 
Then someone is required to publish these data on the root-chain including a Merkle proof attesting that the published data is the same as on the plasma chain. 
This is a problem, since providing data on the root-chain can be quite costly. 
Our solution is that the requester needs to pay some decent fee to the data-provider, in order to prevent grieving attacks. 
But this leaves the construction with a tragedy of the commons, as no one, in particular, would have the incentive to ask for the data in case of a real data-unavailability case. 
But still, this action would be required from someone. 

Since we estimate the costs of this data-request on the root chain to be definitively lower than 10 Dollar, the tragedy of the commons is very small. 
There should always be a party, which request the data for everyone else. Hence, it is a reasonable trade-off. 

Since the plasma plasma operator will never intentionally generate these situations, as it will hurt his reputation, the incentives are well set. 

\subsection{Performance}
There are some bottlenecks, which are considered for evaluating the performance:
\begin{itemize}
\item Price calculation. 
Finding these uniform clearing prices is a non-linear optimization problem. 
The solving time to find these prices increases exponentially with the number of tokens involved. For concrete timings, take a look at \cite{priceOptimization}
\item Generating the public verification keys for the snark proofs is a very challenging task having its own limitations. 
But we think that we can generate these verification keys for trade blocks with $2^{16}$ transactions. 
The calculation of the actual proof should then be feasible within a minute. 
\item Gas costs for bitmap and other data, which needs to be made available on the root-chain. 
Uploading a bitmap with 9000 entries costs about 100k gas. 
\item Plasma exists.
Plasma exits are controversially discussed in the community. 
If there are too many utxo, which want to exit all at the same time, - maybe triggered by a data-unavailability -, the root chain will be under heavy load and gas prices might spike. 
\end{itemize}
We think that the price calculation is the biggest bottleneck. 
But still, we are confident that we will be able to schedule auctions every 3 minutes with about $2^{16}$ orders. 
\subsection{Complexity}
Unfortunately, the described mechanisms are quite complex. 
Shipping such a complex construction without any bugs will require a huge engineering effort. 
Hence, Gnosis is planning to cut out some features and add them only in the next versions of its product. 

The following pieces can reduce the complexity:
\begin{enumerate}
\item
DKG can be replaced with one single entity, which is very trustworthy. 
This single entity would only generate the public keys and later reveal the private keys for it. 
This does not put customers funds at risk at any point in time. 
\item
The described mechanism \ref{publicPrices} making it possible to everyone to submit the best prices can be left out. 
\end{enumerate}



\subsection{Claiming Fees}
For trading or transferring tokens on the plasma chain the operator will charge some fees. In order to keep the fee collection as modular as possible, we plan to charge the fees via external state channels.

\section{Open research questions}

\subsection{Future iterations}
We hope that in future iterations, we can outsource more and more logic to the snarks proofs. 
This has the potential to improve the user experience a lot since verification times will be reduced and double signing processes can be omitted. 

\subsection{Plasma rollovers}
In order to reduce the verification time for clients, a potential solution is a chain rollover. 
That is, all transaction outputs needs to be spend all 3 weeks. 
If people do not send them to themselves within 3 weeks, they will not longer be exit-able from the plasma chain. 
In a plasma chain, where transactions are for free, this is a viable model. 
It does not really come with any new burdens for the users, as the user needs to be online and check the validity of the chain anyways.

But it would have the big benefit that not the whole chain needs to be stored and processed, but only the blocks of the last 3 weeks. 
\begin{appendices}
\section{ECIES}
\label{ECIES}
The ECIES design works in the following fashion:
The DKG algorithm generates a public key represented as an elliptic point $aG\label{public key}$, for a generator G of a elliptic group and a secret $a\in \mathbb{N}$ (cp. \cite{DKG}).  Each trader calculates $bG \label{salt}$ for a random natural number b and publishes the point $bG$  in his order. 
Then he calculates: $baG$ and determines from this number the symmetric key pair for encrypting his order. 
A good symmetric encryption mechanism might be the Knudsen-Nyberg cipher\cite{cipher}, as this one would be efficient to calculate and verify using snarks in the price correctness proof \ref{proofprices}.
Later, once $a$ is public, we can decrypt the orders by calculating the symmetric key pair from $abG$, which equals $baG$.

\section{An elaboration on the snark mechanism}
\label{snarkElaboration}
Let $\mathcal{B}_O$, $\mathcal{H}_V$ and $\beta$ denote the order-block \ref{orderblock}, volume-hash \ref{volumeBlock} and bitmap introduced above (respectively). 
Let us denote the decrypted orders from the $\mathcal{B}_O$ as list $\text{[orders]= [}\sigma_1, \sigma_2\text{,...]}$ and the trading volume of each order by the list $\text{[volumes] = [}\nu_1, \nu_2\text{...]}$, where the volume $\nu_i$ corresponds to the order $\sigma_i$. 
The public key used to encrypt all orders will be denoted by $\text{key}_p$.
In order to run the proofs the most efficient, we need to calculate a special hash:
\begin{equation}
h = \text{sha256}(M_R(\mathcal{B}_O),\mathcal{H}_V, \text{sha256}(\beta), M_R(\vec{p}), \text{key}_p) 
\end{equation}
where $\vec{p}$ is the price vector \ref{pricevector}.

Then the program P(i,w) should prove the above mentioned facts. 
The public input into P is declared by the variable i and w will be the witness. 
In details it will look like:

\begin{equation}
\text{P(i=h,}
\text{w=([orders],[volumes],[prices],[bitmap]))} 
\end{equation}
And P would check that:
\begin{enumerate}
\item  \begin{enumerate}
  \item Calculate $M_R(\mathcal{B}_O) := M_R(\text{Encrypted[orders]})$
    \item Calculate  $\mathcal{H}_V := M_R(\text{[orders]} \cup \text{[volumes]})$,\newline
where $\text{[orders]} \cup \text{[volumes]} = \text{[order}_1, \text{volume}_1, ...] $
  \item $M_R(\vec{p}) := M_R(\text{[prices]})$ and
    \item check i equals $ \text{sha256}(M_R(\mathcal{B}_O),\mathcal{H}_V, \text{sha256}(\text{bitmap}), M_R(\vec{p}), \text{key}_p) $
    \end{enumerate}
\item P would check that only orders which were double signed have a positive trading volume:
\begin{equation}
\forall o \in \text{[orders], vol}(o)>0 \implies \text{bitmap}(o) = 1 
\end{equation}
\item The equations \ref{limitprice_sat} and \ref{volume_balance} hold
\item For each trading pair, P loops through all orders and memorizes the highest limit price of an order of this pair, which still has a positive trading volume. 
Then it loops through them again and checks that no other order with a lower limit price has not been filled. 
\end{enumerate}


\end{appendices}
\begin{thebibliography}{9}
\bibitem{DKG} 
Caimu Tang
\textit{ECDKG: A Distributed Key Generation Protocol Based on Elliptic
Curve Discrete Logarithm.}  
https://pdfs.semanticscholar.org/3c52/35523be1d305de6dbf3433965c99d9fe4aea.pdf
 

\bibitem{priceOptimization} 
Gnosis
\textit{Multi-token Batch auctions with uniform clearning prices}  
https://github.com/gnosis/dex-research/tree/master/BatchAuctionOptimization

\bibitem{plasma} 
Vitalik Buterin and Joseph Poon
\textit{Plasma}.
https://plasma.io/plasma.pdf

\bibitem{MVP} 
Vitalik Buterin
\textit{Plasma minimal viable product}.
https://ethresear.ch/t/minimal-viable-plasma/426
 
\bibitem{sig} 
Crypto aggregated signatures
\\\texttt{}
https://ethresear.ch/t/cryptoeconomic-signature-aggregation/1659

\bibitem{snarks} 
Snarks using the library Zokrates
\\\texttt{snarks}

\bibitem{ECIES} 
ECIES
\\\texttt{ECIES}
https://crypto.stackexchange.com/questions/31602/how-does-encryption-work-in-elliptic-curve-cryptography

\bibitem{cipher} 
Knudsen-Nyberg cipher
\\\texttt{ Knudsen-Nyberg cipher}
https://eprint.iacr.org/2016/492.pdf


\bibitem{batch} 
Batch Trading - \href{https://www.investopedia.com/terms/b/batchtrading.asp}{https://www.investopedia.com/terms/b/batchtrading.asp}

\bibitem{zokrates} Snarks - \href{https://github.com/JacobEberhardt/ZoKrates}{https://github.com/JacobEberhardt/ZoKrates}

\end{thebibliography}

\end{document}
