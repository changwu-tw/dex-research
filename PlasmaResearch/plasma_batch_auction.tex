\documentclass[11pt,parskip=full]{scrartcl}%article}
%\setlength{\parskip}{1em}

%%%%%%%%%%%%%%%%%%%%%%
%% PACKAGE INCLUDES %%
%%%%%%%%%%%%%%%%%%%%%%

\usepackage{array}           % For defining \newcolumntype.
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}          % Provides 'proof' environment.
\usepackage[english]{babel}  % For defining 'theorem/corollary/lemma' environments.
\usepackage{bm}              % Provides bold \pi
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{gensymb}         % Enables \degree command for Â°C.
\usepackage{todonotes}
\usepackage{subfig}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{listings} % http://ctan.org/pkg/listings
\usepackage{amsmath}

\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\usepackage[toc,page]{appendix}

%%%%%%%%%%%%%%%%%
%% STYLE SETUP %%
%%%%%%%%%%%%%%%%%

% Define some custom colors.
\definecolor{mylinkcolor}{RGB}{000, 114, 166}
\definecolor{mycitecolor}{RGB}{255, 154, 071}
\definecolor{myurlcolor}{RGB}{000, 114, 166}

% Set itemize format.
\setitemize{noitemsep,topsep=-5pt,parsep=5pt,partopsep=0pt}

% Define column types that allow fixed width params.
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

% Color setup for hyperlinks/references/citations/urls.
\hypersetup{
    colorlinks,
    linkcolor={mylinkcolor},
    citecolor={mycitecolor},
    urlcolor={myurlcolor}
}

% Specify hyphenation of words on line break.
\hyphenation{Figure Table Chapter Section}

\long\def\/*#1*/{}



%%%%%%%%%%%%
%% MACROS %%
%%%%%%%%%%%%

% Set default font family to sans-serif.
\renewcommand*{\familydefault}{\sfdefault}
\newcommand{\Tau}{\mathrm{T}}

\newcommand*{\ie}{i.e., }
\newcommand*{\eg}{e.g., }
\newcommand*{\wrt}{w.r.t. }

\newcommand*{\tokens}{\mathcal{T}}          % Set of tokens.
\newcommand*{\orders}{\mathcal{O}}          % Set of orders.
\newcommand*{\itokens}{\mathcal{I}^t}       % Set of token indices.
\newcommand*{\itokenpairs}{\mathcal{I}^p}   % Set of token index pairs.
\newcommand*{\iorders}{\mathcal{I}^o}       % Set of order indices.
\newcommand*{\ibuyorders}{\mathcal{I}^b}    % Set of buy order indices.
\newcommand*{\isellorders}{\mathcal{I}^s}   % Set of sell order indices.

% Macros for references etc.
\newcommand*{\figref}[1]{\hyperref[{#1}]{Figure~\ref*{#1}}}
\newcommand*{\tabref}[1]{\hyperref[{#1}]{Table~\ref*{#1}}}
\newcommand*{\secref}[1]{\hyperref[{#1}]{Section~\ref*{#1}}}
\newcommand*{\subsecref}[1]{\hyperref[{#1}]{Section~\ref*{#1}}}
\newcommand*{\thmref}[1]{\hyperref[{#1}]{Theorem~\ref*{#1}}}
\newcommand*{\crlref}[1]{\hyperref[{#1}]{Corollary~\ref*{#1}}}
\newcommand*{\lemref}[1]{\hyperref[{#1}]{Lemma~\ref*{#1}}}

% Macros for theorems|corollaries|lemmas.
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

%Notational abbreviations

\def\pO{\mathcal{O}}
\def\ra{\rightarrow}

\newcommand*{\erc}{ERC20 }
\DeclareMathOperator{\sha}{sha256}


%%%%%%%%%%%%%%
%% DOCUMENT %%
%%%%%%%%%%%%%%

\title{
  Multi-token Batch Auctions with Uniform Clearing Prices on Plasma\\
  - \\
  \Large Specification For Implementation}
\author{Gnosis}

\date{\today}



\begin{document}

\maketitle


\begin{abstract}

This document outlines a formal specification of a batch auction exchange of ERC20 tokens using the plasma technologies. 
The batch auction mechanism will enable the execution of ring trades between different tokens. 
Plasma technologies will provide - under some assumptions - the same security for users as if the tokens were held in the ethereum blockchain. 
However, gas costs will be significantly reduced due to the off-chain nature of the exchange mechanism. 
It is recommended for the reader to familiarize themselves with Plasma\cite{plasma}, Plasma MVP\cite{MVP}, snarks\cite{snarks} and batch auctions\cite{batch} before reading this spec. 

\end{abstract}

\tableofcontents

\newpage
\section{Introduction}
\label{sec:introduction}

\paragraph{Multi-batch auctions with uniform clearing prices}

This specification outlines a trading mechanism between several \erc tokens. Each batch accepts orders to buy any \erc token with any other \erc token for a maximum specified limit price. All orders are collected over some time interval and then a \emph{uniform clearing price} over all token pairs is calculated. 

For a list of $n$ trading tokens denoted by $\Tau$ with clearing prices $\{p_{ij}\}$, we call the set of prices $\{p_{ij}| \tau_i, \tau_j \in \Tau\}$ a uniform clearing price if, for all $1 \leq i, j, k \leq n$
\begin{align} \label{arbitrage_free}
  p_{ij} \cdot p_{jk} &= p_{ik}\\
  p_{ij} &= p_{ji}^{-1}
\end{align}

These equations imply that there is no arbitrage opportunity between any of the $n$ tokens within one auction.
Finding the uniform clearing prices, which also maximize trading volume or other predefined metrics is a complicated task. One possible mechanism is described in detail in \cite{priceOptimization}. Uniform clearing prices are beneficial for any trader since they are arbitrage-free and ensure good liquidity via built-in ring trades. For the purpose of this document, it is assumed that these uniform clearing prices for a multi-batch auction can be efficiently determined. \newline
The multi-token batch mechanism is secured against front-running\footnote{An actor entering into an equity/asset trade with foreknowledge of a transaction which will influence the price} by allowing users to submit encrypted orders into the batch auction. Only after the batch has closed the orders will be revealed and then the prices will be computed. 


\paragraph{Plasma minimal viable product}

This paper describes the specification for porting this auction mechanism onto a plasma chain \cite{plasma}. Plasma chains are a second layer scaling solution for blockchains which allow processing a much higher volume of transactions as the underlying blockchain (a.k.a. \emph{root-chain}) with the same security guarantees\footnote{Under the assumptions that transactions are not censored on the root-chain for a longer period of time, and the plasma clients stay online and validate the plasma chain frequently}. This is the main motivation for implementing such mechanism on a plasma chain as it will result in significantly less costs per trade. We are planning to use Ethereum as the root-chain. 

\paragraph{The trade-flow of a batch auction}  

The batch auction exchange is built on a plasma chain operated by a single entity on top of a root-chain. A single batch auction consists of several phases:
\begin{itemize}
\item[(i)] Encryption Key Generation, 
\item[(ii)] Order Collection, 
\item[(iii)] Double Signing, 
\item[(iv)] Decryption Key Generation,
\item[(v)] Batch Price Calculation,
\item[(vi)] Batch Challenging and 
\item[(vii)] Order Executions. 
\end{itemize}
While the plasma operator has some flexibility on closing batches, an auction is expected to take roughly 3 minutes.
In brief, a batch will proceed as follows: Users will post encrypted orders to the plasma operator, who will then bundle these orders and commit them by posting a single order-block on the plasma chain.
Each client will have to validate the orders of this order-block. Only once they have validated the orders, they may double sign their orders to participate in the current batch.
The participation acknowledgment will be compactly represented using a crypto-economic signature aggregation schema. With this construction many data-unavailability problems will be avoided because the orders can be represented on the root-chain using only a bitmap.
Once the bitmap is seen on the plasma chain, the private key for decrypting the orders will be generated using distributed key generation (DKG). Finally, all the data is available to calculate correct prices from the orders and the batch can be settled. 


\newpage

\section{Detailed specification overview}
\subsection{Setup description}

\subsubsection{Definitions}


%Let us start of with writing down some very basic definitions, which we will use throughout this paper.
In our batch auctions all trading will occur between a fixed set, $\Tau = \{\tau_i\}_{i=1}^n$, of $n$ \erc tokens. The collection of orders for which token $\tau_i$ is being sold in exchange for token $\tau_j$ will be denoted by $\pO_{i\ra j}$. 

After an auction has been closed and uniform clearing prices have been determined, the price matrix can be represented as an $n\times n$ matrix 
\[P = \{p_{ij}| \tau_i, \tau_j \in \Tau \}.\]
Due to the equation \ref{arbitrage_free}, it is enough to define the uniform clearing price as a one-dimensional vector with respect to a reference token $\tau_i$:
\[ \vec{p}_i = \{p_{ij}| \tau_j \in \Tau \}.\]
The vector
\begin{equation}
\vec{p} =\{ p_{ij}| \tau_j \in \Tau \} \quad \text{with} \quad \tau_i =\text{ETH}
\label{pricevector}
\end{equation}
will be called the \emph{price vector} of an auction.\newline
For any order $\sigma \in \pO_{i\ra j}$ we define $\nu_p(\sigma)$ as the volume of an order denominated in token $\tau_i$ at clearing prices $p$.


\subsubsection{Plasma chain setup}
We are following the description of the Plasma Minimal Viable Product\cite{MVP}. 
This means all assets are represented in the plasma chain as unspent transaction outputs (utxo). 
These utxos can be transferred to a new owner by making a transaction, waiting for its inclusion into the plasma chain, validating the chain, waiting for the plasma block to be submitted to the root-chain and then, sending a double-sign message to the receiver. 

Any utxo may be exited at any time, by providing a Merkle proof of the receiving transaction and its double signing. 
However, if the exit is not valid, then it will be canceled via a challenge process.
The MVP also defines a \emph{maximum-time-of-absense}\label{exit-time}, which is usually set to 7 days. The plasma MVP requires people to validate the plasma chain frequently.
The time difference between two consecutive validations should not be bigger than maximum-time-of-absense.


\subsection{The trade flow}
\label{subsec:data}

In the following section we will describe the general trade-flow for the batch auction through all its phases.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{overview_tradeflow.png}
\end{figure}



\subsubsection{DKG: Encryption Key Generation}
All orders will be encrypted with a public key generated by the Distributed Key Generation (DKG) algorithm \cite{DKG}. 
A predefined number of bonded participants will be part of the DKG algorithm. 
By exchanging special messages and withholding others, they will generate a new public key for which the private decryption key is not known to any single participant. 
Only later, after the auction closes, in a second step the DKG participants are requested to publish their private messages for the generation of the private key for the decryption of the orders.
If a predefined threshold of participants publishes it, this will allow anyone to generate the private key. 
If the participants try to collude and share their private messages before the closure of the batch, anyone can reveal these secret messages on the root-chain. This would slash the owner of the secret and reward the publisher. This mechanism ensures that the DKG participants are heavily incentived to do not participate in any collusion. 
With this approach, we have encrypted yet binding orders, unless a large portion of bonded DKG participants are malicious. 

Only if not enough DKG participants reveal their private information and the threshold is not reached, we have to revert the last auction (cf. \ref{enforceAvailablity}).


The public key generated by the DKG procedure can then be used to encrypt messages via the ECIES \cite{ECIES}. 
The ECIES design for our purpose is described in the appendix \ref{ECIES}.


\subsubsection{Order Collection}
\label{orderblock}
Once the public key for the encryption process is available, every trader can submit orders. 
In the plasma chain, all assets of the ERC20 tokens are represented by unspent transaction outputs (utxo). 
An order $\pO_{i\ra j}$ will refer to a utxo of an \erc token $\tau_i$ and this utxo will be exchanged for the specified target token $\tau_j$ for a price below the given limit price. The target token and the limit price will be encrypted.

\begin{verbatim}
Order [ utxo,
    Encrypted(Token j),
    Encrypted(LimitPrice),
    EncryptionSalt,
    Signatures]
\end{verbatim} 
The encryption salt is an elliptic point used for encryption (cf. \ref{salt}). 
The signatures will include the double signature of the utxo and the actual signature of the order.
All orders will be collected and broadcast in one block per auction, the \emph{order-block}. 
Additionally, we will publish the $\sha$ of the string of series of orders which will be required later to efficiently generate a snark proof.
All orders included in this order-block will be able to participate in the next auction. 
Theoretically, the plasma operator could censor orders, but since they are encrypted, no meaningful information could be obtained.
However, due to storage constraints (i.e. no more than $2^{16}$ orders per auction), the operator would be required to monitor the number of orders at any given time.
If there are a lot of orders placed the operator will charge a small fee for each order placement via a separate state channel. 
In the case that a participant seeks to cancel their order, they can notify the plasma operator or simply do not double sign their order. 

\subsubsection{Double Signing}
Once the order-block is published and its Merkleroot hash is submitted to the root-chain, every participant in the batch auction must validate the current state of the system. 
Once they commit that their order should be included in the next batch, they will be able to withdraw their order funds only with the priority\footnote{as defined by the Plasma MVP exit mechanism} of this order-block - this will be explained in detail here: \ref{exitRules}.

If participants validated the whole chain, they can send the operator the double signing message to signal their desire to participate. 
\begin{verbatim}
DoubleSign [OrderHash, BatchIndex, Signature]
\end{verbatim}

The operator collects all these DoubleSign messages and constructs a \emph{bitmap}, in order to generate a crypto-economic signature aggregation (cf.\cite{sig}). 
The $i^{th}$ bit of this map is equal to 1 if the operator receives a DoubleSign message for the $i^{th}$ order, and is 0 otherwise.
The operator then publishes this bitmap along with all DoubleSign messages in a next plasma block. We will refer to this block as the \emph{confirmation-block}.\newline
In the event that the bitmap is unavailable or incorrect, anyone may request the operator to publish it on the root-chain.
Then the operator can be challenged by requesting him to show the DoubleSign message and its Merkle-proof.
The operator or anyone else could provide these information. 
In case the data is not provided and the challenge is successful, we will revert the auction belonging to the challenge (cf. \ref{exitRules})


It is clear that the process of double signing will hinder the user experience (since users would have to remain online for the duration of the auction an then act again). 
However, the possibility of granting allowance to a third-party service could be available if desired.
This would, of course, involve some level of trust in the service, but this would be limited, as this service would not be capable of altering an order. That is to say, the service would only be granted permission to double sign.

\subsubsection{DKG: Private Key Generation}
Once the plasma block, containing the bitmap is published and submitted to the root-chain, the DKG participants will publish their hidden messages used for generating the DKG-public key. 
Once the threshold for the private key generation is reached and there are enough messages available to generate it, the private key will be broadcast to all participants by the plasma operator.

\subsubsection{Auction Result Publication}
\subsubsection*{Price Determination}
Upon publication of the batch auction's private key, the operator will proceed in trying to find of the optimal price-matrix between all \erc tokens from the current batch of orders. 
While trying to find the optimal solution, he will also iteratively calculate the lower and upper bounds for the solutions. Once the difference between the upper and lower bounds is smaller than a predefined threshold, the plasma operator will stop the calculation and publish the uniform clearing prices.\newline
As stated in before, the uniform clearing prices can be specified via a price vector \ref{pricevector}:
\begin{equation}
\vec{p}=\{ p_{ij}| \tau_j \in \Tau \} \quad \text{with} \quad \tau_i =\text{ETH}
\end{equation}

\/* 
\begin{lemma}
Any price matrix $P = [p_{ij}]$ subject to the constraint \ref{arbitrage_freeness} of arbitrage-freeness is enjoys the following properties;
\begin{itemize}
\item[(i)] $P$ is multiplicatively-symmetric\footnote{i.e. $P^\dagger = \frac{1}{P}$ where $P^\dagger$ denotes the point-wise transpose}. Equivalently, this the result of equation \ref{symmetric_pricing}.
\item[(ii)] The diagonal of $P$ consists entirely of 1's.
\item[(iii)]  $P$ is uniquely determined by its super-diagonal entries $\{p_{i, i+1}\}_{i=1}^{n-1}$.
\end{itemize}
\end{lemma}
*/
Along with this price vector, the plasma operator would also share the trading volumes in a compact manner. 
This will be done using a mapping $m$ from the order index to the trading volume\emph{volume-list}\label{volumeBlock}. 
Note that only the trading volumes for fractionally fulfilled orders would be stored.

\[
    m(\sigma)= 
\begin{cases}
    \text{trading volume},& \text{if } \sigma \text{ is partially filled}\\
    1,        & \text{if } \sigma \text{ is fully filled and the has highest limit price for one pair}\\
    0,              & \text{is not touched} \\
    0,              & \text{is fully filled, but not highest limit price} \\
\end{cases}
\]
This mapping $m$ will be stored on the root-chain, in case of a data unavailability. 
In the plasma chain, we will store only the \emph{volume-hash}, that is the Merkle root of the following array:
\[[m(\sigma_1), m(\sigma_2), \dots, m(\sigma_n)].\]

There is no guarantee that every order with a limit price below the uniform clearing price will be completely executed. 
Hence, the trading volume must be specified for each order.
This may come across as non-intuitive but does occur in batch auction trading.


\subsubsection*{Proof of Correctness and Fairness}
\label{proofprices}
Once the prices are calculated by the plasma operator, he needs to prove that this set of prices is actually valid and fair. 
A price set and a volume-list \ref{volumeBlock} is valid and fair, if

\begin{enumerate}

\item the price set is arbitrage free (cf. equation \ref{arbitrage_free} )
\item orders have only a non-negative volume, if the orders are valid. Submitted orders can be invalid, if the specified encrypted target token is not in the list of traded tokens.
\item orders are only touched, if the limit price is below the calculated price:\newline
\begin{equation} \forall \tau_i ,\tau_j \in \Tau \quad \forall \sigma \in \pO_{i\ra j}, \quad \nu_{p_{ij}}(\sigma)>0 \Rightarrow p_{ij}\geq \text{p}(\sigma)
\label{limitprice_sat}
\end{equation}
\item the amount of sell volume for a token equals its buy volume: 
\begin{equation}
\begin{split}
\forall \tau_i \in \Tau \quad \sum_{\tau_j\in \Tau} \,
\sum_{ \sigma\in \pO_{i \rightarrow j}} \nu_{p_{ij}}(\sigma) = \sum_{\tau_j\in \Tau} \, \sum_{\sigma\in \pO_{j\rightarrow i}} \frac{\nu_{p_{ji}}(\sigma)}{p_{ji}}
\label{volume_balance}
\end{split}
\end{equation}
\item If an order $\sigma \in \pO_{i\rightarrow j}$ with a limit price $p$ has a positive trading volume, then every order in $\pO_{i\rightarrow j}$ with a lower limit price should be completely fulfilled. 
\end{enumerate}


In order to prove this, we will use a true-bit calculation \cite{truebit}. 
All these statements can be checked either by providing a direct proof of by the a true-bit game. 
The most advanced part is to verify the calculation of the sum \ref{volume_balance}. 
If any trader has any doubt that the equation is not fulfilled, they will request the operator to commit all the prices and trading volumes via the mapping $m$ to the root-chain. 
They can then start the true-bit game by putting up a bond. 
Together with the plasma-operator, they will calculate the sums in an interactive game. 
If the challenger loses, the operator will gain the bond, otherwise the challenger will win a bond from the operator and the plasma chain will come to a halt.

\subsubsection*{Auction-result-block}

Once the operator has the price vector $\vec{p}$, the volume-list and the proof, all this information will be published in one \emph{auction-result-block}. 
The operator will publish this block on the plasma chain. 


\subsubsection*{3rd Party Price Submission [Optional]}
\label{publicPrices}
In the simplest implementation, the plasma operator will always provide the prices. But this requires some faith in the plasma operator, as there is no guarantee that the final prices are optimal, i.e. that they really optimize a predefined traders welfare metric.
A little bit more advanced implementation could also accept price submission on the root-chain by any person. 
The smart contract on the root-chain would select the price submission as the final price, which is valid, has a snark valid proof of correctness and fairness and has the best score with respect to the predefined metric. Of course, we would need to modify the snark proofs a little, since they would also be required to prove the score in the trader's welfare metric. 

In this case, the price submitter would also need to provide the volume-list (cf. \ref{volumeBlock}) or at least assist traders with their exits games, by providing the Merkle proofs for their trading volumes (cf. \ref{exitRules}). 


\subsubsection{Enforcing Key Variable Publication}

\label{enforceAvailablity}
In case the operator goes off-line and we get a data-unavailability, we still want to make sure that the last auction can be completed by all participants or it will be cleanly un-rolled. 
Since data-availability on the plasma chain is subjective, we need to make sure that all necessary information will be loaded into the root-chain, in the worst case. \newline
For loading either the bitmap, price vector, volume-hash or proofs in the root-chain we have the following procedure:
\begin{enumerate}
\item By default we publish the data only in the plasma chain
\item If a user does not see any of the data, he can send a request to publish the data on the root-chain. This request requires some additional fee, which cover the gas costs to answer the request.
\item Then anyone has the chance to answer the request together with a valid Merkle proof, which ensures that the answer is the same as given on Plasma chain. It is enough if the data is only published as payload, the data does not need to be stored completely on the root-chain. The answerer will be compensated with the fee from the requester.
\item If any request is not answered within a predefined \emph{data-request-time}, then the auction referred in the data request will be reverted. We will see later that we can set:
with: \begin{equation}
\text{data-request-time}=\text{maximum-time-of-absense}
\end{equation}
without any security restrictions.
This means that only utxos which were submitted before the order-block of the reverted auction will be accepted for any withdraw (cf. \ref{exitRules}). 
\end{enumerate}

For the following data, we will use this procedure:
\begin{enumerate}
\item \emph{bitmap}:
It is essential for everyone to know what the bitmap of an auction is in order to know which orders are in the batch. Since the order-block will contain $2^{16}$ orders, the bitmap size will be $2^{16}$ bits. 


\item \emph{decryption keys}:
Also, the decryption key of an auction is essential to know, in order to see the limit prices of the encrypted orders. 
The size of the private key for decrypting the orders would be $2 \times 32$ bytes.

\item \emph{prices}:
The prices are also essential to know for each participant. 
If they are not public, again they can be made public with the same mechanism. 
We note that the gas costs for publishing the prices increase linearly with the number of tokens.

\item \emph{price verification}:
Everyone must be able to validated the prices and trading volumes. 
Hence, everyone may request for exchange of a fee that the operator publishes the trading volume-list and volume-hash (cf. \ref{volumeBlock}). 
The cost of publishing these volume-lists grows quadratically with the amount of tokens traded in the batch. 
We plan to have 10 tokens traded initially and hence in the worst case scenario would need to store 100 variables 
\end{enumerate}

\subsubsection{Order-output Transactions}
After the auction-result-block is published, the operator will publish another block with all order-output transactions. For every order in the order-block, we will insert one order-output transaction into the order-output block. 
An order-output transaction for an order within $\pO_{i\ra j}$ will have the following format:
\begin{lstlisting}
OrderOutput [ OrderIndex,
    $oo_j$, Token j,
    $oo_i$, Token i,
    orderCreator]
\end{lstlisting}
The OrderIndex is the index of the referred order within the order-block.
The first order-output [$oo_j$, Token j] denomiated in token $\tau_j$ is the trade output, which a trader gets for his input via the trade. 
The second order-output [$oo_i$, Token j] denomiated in token $\tau_j$ is the amout of input, which has not been traded. That means this second order-ouput is only positive, if the order has not been touched or the order could only be filled partially.
The order-output ($oo_j$) will be calculated as:
\begin{equation}
  oo_j = p_{ij} \times \text{OrderInputAmount} \times \nu(\text{order}) 
    \label{fee_equ}
\end{equation}
where $\nu(\text{order})$ is the volume declared in the volume-list.  
Whereas, the order-output ($oo_i$) is defined by:
\begin{equation}
  oo_i =  \text{OrderInputAmount}\times (1 - \nu(\text{order}))
\end{equation}
These order-outputs can then be spent again via a transaction, but cannot be used as an input for another order. 
If any of these order-outputs is not correctly created by the plasma operator, people have to leave the plasma chain. 
Then the last batch will be settled on the root-chain or be reverted, depending on the availability of auction-result-block (cf. \ref{enforceAvailablity}). 



\subsubsection{Auction scheduling process}

An auction can have a variable timing. 
The operator can decide on his own when to close the batch and create the order-block \ref{orderblock}. 
Once this block is posted, it will take some time until the orders are processed. 
The operator will ensure a smooth flow by accepting new orders right away. 
Hence, batch auctions can be scheduled one after the other without any waiting time. 
However, these orders and all transfers could be reverted if the chain halts. 
The finality of an auction is only guaranteed after the client sees the auction-result-block, since with the knowledge of this block, they can answer all data-requests on the root-chain and thereby ensuring the finalization of the batch.

\subsection{Exit rules of the plasma chain}
\label{exitRules}
\paragraph{Transfer transactions} have similar exit rules, as in the usual plasma mvp. 
But there are two differences.
\begin{itemize}

 \item We would maintain a variable \emph{highestExitPriority}. 
This highestExitPriority would be infinity in normal cases. 
But if the plasma chain is halted, because a data-unavailability request (cf. \ref{enforceAvailablity}) was not answered in a certain time frame, then this variable will play an important role. 
It will set the highest exit priority to the priority of the last block, before the order-block submission. 
Any utxo generated after highestExitPriority will not be exitable and any exit request cannot be challenged with a utxo spend after this highestExitPriority. 
Effectively, we are resetting the plasma state to a previous state by setting highestExitPriority. 
\item Any utxo can be challenged as spent and not exit-able, by showing an order, a double signing of the order. Of course the Merkle proofs for this data have to be provided.

\end{itemize}

\paragraph{Order transactions} can also be referenced for an exit request. The request are put into the same priority queue as the normal exits. They must prove that
\begin{enumerate}
\item the order was included in the plasma chain by providing a Merkle proof
\item the order was double signed, by providing the bitmap and its merkle proof.
\item the trading volume of the batch auction by a Merkle proof with the volume-hash as root hash.
\end{enumerate}
For a "touched" order in $\pO_{i\ra j}$ only the order-outputs can be withdrawn, but not the order-input. 
Hence, trades are enforced and cannot be reverted arbitrarily. 

If a data-unavailability appears right after the closing the batch, the order-output transaction might be already in a plasma block. 
These order-outputs cannot be used to challenge an order exit. 
Only if the order-output is already spent and double signed, then the order exit process can be challenged successfully. 

It may occur that a trader does not know the trading volume of their order in the last batch auction because neither the auction-result-block nor the order-output block are available to them. 
Then, they would not be able to provide the Merkle proof to attest their positive trading volume. 
In this case, they would request for the completion of their exit on the root-chain by requesting the submission of the Merkle proof with the trading volume. 
If neither the plasma operator nor anyone else does answer this exit request within the predefined time $\text{data-request-time}$, then the auction will be stopped and all trades will be reverted, if the auction is not older than the maximum-time-of-absense (cf. \ref{exit-time}). If the auction was not conducted within the maximum-time-of-absense, then the exit requester should have the data.

Order withdrawals can be challenged by showing providing a double signed transfer of the order-output in the plasma chain. This sufficies since we do not allow orders to reference other orders as a trade input.

\newpage

\section{Features}

\subsection{Trade enforcement}
Trades on this exchange will usually be enforced. 
That is, if an order was submitted, double signed and was touched by auction price, then the actor can only withdraw the trade-output nominated in the target token. 
But the trader will not get back his trade input. 

Unfortunately, some actors have an advantage.
If many DKG key holders do not reveal the decryption key, they can stop the chain. 
The DKG algorithm works with a predefined threshold. 
Only if more DKG participants as specified by the algorithm do not reveal their private input, then the batch cannot be executed. 
But in this case, we could also slash these DKG participants, which are misbehaving. 

\subsection{Safety in case of a data-unavailability}

\subsubsection{Token transfers}
For token transfers, we have the same data-unavailability fallbacks, as the MVP product. 
A double sign mechanism and the priority queue mechanism protects people from losing funds. 
It becomes slightly more complex, as users should not double sign a transaction, which happens right after the closing of a batch.
Only after they validated the entire process of the batch closing, they should double sign their transfers.
In order to ensure that the transfer is not reverted anymore, they need to be online and answer any data-request on the root-chain. Since we set $\text{data-request-time} = \text{maximum-time-of-absense}$ (cf. \ref{enforceAvailablity} and \ref{exitRules}) this is no really an additional requirement.\newline
If traders are online regularly within maximum-time-of-absense intervals, they will always get a better priority than any malicious utxo.

\subsubsection{Matched and unmatched orders}
Also for traders, the safety is guaranteed by a  double signing and priority exit mechanism. 
If there is anything incorrect, before the double signing step, traders will just not double sign their batch. 
Then they can still exit their utxo. \newline

If any network attack happens right after the order-block, the traders withdrawal priority of their order-output will be determined by the order-block.
Hence, their priority will still be higher than any withdrawal request of this attack.
This ensures that traders will always get their funds back or they can settle the last batch via the on-chain exit. 
If any data is unavailable for settling the trade with an exit request after the double signing step, then this data can be requested to be uploaded to the root-chain. 
Since the data is published within $\text{maximum-time-of-absense}$, any exit request asking also for data is getting the data in time. 
Having not all the data in the exit request does not prevent anyone from challenging the exit, hence there is no interference with the usual plasma exit scenarios.


If the data from exit requests are not published, the batches being reverted are at most $2 \times \text{maximum-time-of-absense}$ old. 
Since plasma withdrawals of utxos, which are newer than the $2 \times \text{maximum-time-of-absense}$, are not allowed, there is no risk that any of the reverted utxo will be already withdrawn.
We only need to reset exit requests on the root-chain, which are no longer valid, because the chain has been reset. 
For a detailed description of the data, which needs to be made available, see here: \ref{enforceAvailablity}. 


\subsection{Non-custody of funds}
From the above analysis, we can conclude that the plasma operator has never the ability to steal tokens, if
\begin{enumerate}
\item all users come online regularly and behave correctly. 
\item users transaction are not censored over a long time interval on the root-chain
\end{enumerate}
This is one of the key features of our construction. 

\subsection{Grieving vectors and tragedy of the common}
Unfortunately, our specification had to take some trade-offs. 
The main problem is that data-unavailability is subjective. 
Hence, people can always claim that data is missing. 
Then someone is required to publish these data on the root-chain including a Merkle proof attesting that the published data is the same as on the plasma chain. 
This is a problem, since providing data on the root-chain can be quite costly. 
Our solution is that the requester needs to pay some decent fee to the data-provider, in order to prevent grieving attacks. 
But this leaves the construction with a tragedy of the commons, as no one, in particular, would have the incentive to ask for the data in case of a real data-unavailability case. 
But still, this action would be required from someone. 

Since we estimate the costs of this data-request on the root-chain to be definitively lower than 200k gas, the tragedy of the commons is very small. 
There should always be a party, which request the data for everyone else. Hence, it is a reasonable trade-off. 

Since the plasma operator would loose his reputation if the data is not available and participants need to request it, the operator will always try to provide the data at all times. Thus, these griefing situations should not occur anyways.

\subsection{Performance}
There are some bottlenecks, which are considered for evaluating the performance:
\begin{itemize}
\item Price calculation. 
Finding these uniform clearing prices is a non-linear optimization problem. 
The solving time to find these prices increases exponentially with the number of tokens involved. For concrete timings, take a look at \cite{priceOptimization}
\item Generating the public verification keys for the snark proofs is a very challenging task having its own limitations. 
But we think that we can generate these verification keys for trade blocks with $2^{16}$ transactions. 
The calculation of the actual proof should then be feasible within a minute. 
\item Gas costs for bitmap and other data, which needs to be made available on the root-chain. 
Uploading a bitmap with 9000 entries costs about 100k gas. 
\item Plasma exists.
Plasma exits are controversially discussed in the community. 
If there are too many utxo, which want to exit all at the same time, - maybe triggered by a data-unavailability -, the root chain will be under heavy load and gas prices might spike. 
\end{itemize}
We think that the price calculation is the biggest bottleneck. 
But still, we are confident that we will be able to schedule auctions every 3 minutes with about $2^{16}$ orders. 
\subsection{Complexity}
Unfortunately, the described mechanisms are quite complex. 
Shipping such a complex construction without any bugs will require a huge engineering effort. 
Hence, we are planning to cut out some features and add them only in the next versions of its product. 

The following pieces can reduce the complexity:
\begin{enumerate}
\item
DKG can be replaced with one single entity, which is very trustworthy. 
This single entity would only generate the public keys and later reveal the private keys for it. 
This does not put customers funds at risk at any point in time. 
\item
The described mechanism \ref{publicPrices} making it possible to everyone to submit the best prices can be left out. 
\end{enumerate}



\subsection{Claiming Fees}
For trading or transferring tokens on the plasma chain the operator will charge some fees. In order to keep the fee collection as modular as possible, we plan to charge the fees via external state channels.

\section{Open research questions}

\subsection{Future iterations}
In future iterations, it is hoped that we can outsource more and more logic to the snarks proofs. 
This has the potential to improve the user experience a lot since verification times will be reduced and double signing processes can be omitted. 

\subsection{Plasma rollovers}
In order to reduce the verification time for clients, a potential solution is a chain rollover. 
That is, all transaction outputs needs to be spend all 3 weeks. 
If people do not send them to themselves within 3 weeks, they will not longer be exit-able from the plasma chain. 
In a plasma chain, where transactions are for free, this is a viable model. 
It does not really come with any new burdens for the users, as the user needs to be online and check the validity of the chain anyways.

This rollover would have the big benefit that not the whole chain needs to be stored and processed, but only the blocks of the last 6 weeks. 
\begin{appendices}
\section{ECIES}
\label{ECIES}
The ECIES design works in the following fashion:
The DKG algorithm generates a public key represented as an elliptic point $aG\label{public key}$, for a generator G of a elliptic group and a secret $a\in \mathbb{N}$ (cf. \cite{DKG}).  Each trader calculates $bG \label{salt}$ for a random natural number b and publishes the point $bG$  in his order. 
Then he calculates: $baG$ and determines from this number the symmetric key pair for encrypting his order. 
A good symmetric encryption mechanism might be the Knudsen-Nyberg cipher\cite{cipher}, as this one would be efficient to calculate and verify using snarks in the price correctness proof \ref{proofprices}.
Later, once $a$ is public, we can decrypt the orders by calculating the symmetric key pair from $abG$, which equals $baG$.

\section{An elaboration on the snark mechanism}
\label{snarkElaboration}
Let $\mathcal{B}_O$, $\mathcal{H}_V$ and $\beta$ denote the order-block \ref{orderblock}, volume-hash \ref{volumeBlock} and bitmap introduced above (respectively). 
Let us denote the decrypted orders from the $\mathcal{B}_O$ as list $\text{[orders]}= [\sigma_1, \sigma_2, \dots, \sigma_n]$ and the trading volume of each order by the list $\text{[volumes]} = [\nu_1, \nu_2, \dots, \nu_n]$, where the volume $\nu_i$ corresponds to the order $\sigma_i$. 
The public key used to encrypt all orders will be denoted by $\text{key}_p$.
In order to run the proofs the most efficient, we need to calculate a special hash:
\begin{equation}
h = \sha(\sha(\mathcal{B}_O),\mathcal{H}_V, \sha(\beta), \sha(\vec{p}), \text{key}_p) 
\end{equation}
where $\vec{p}$ is the price vector \ref{pricevector}.

Then the program $P(i, w)$ should prove the above mentioned facts. 
The public input into P is declared by the variable $i$ and $w$ will be the witness. 
In details it will look like:

\begin{equation}
P(i=h, w=(\text{[orders],[volumes],[prices],[bitmap]})) 
\end{equation}
And $P$ would check that:
\begin{enumerate}
\item  
\begin{enumerate}
\item Calculate $\sha(\mathcal{B}_O) := \sha(\text{Encrypted[orders]})$
\item Calculate  $\mathcal{H}_V := M_R(\text{[orders]} \cup \text{[volumes]})$

where $\text{[orders]} \cup \text{[volumes]} =[\sigma_1, \nu_1, \dots]$
\item $\sha(\vec{p}) := \sha(\text{[prices]})$ and
\item check i equals $ \sha(\sha(\mathcal{B}_O),\mathcal{H}_V, \sha(\text{bitmap}), \sha(\vec{p}), \text{key}_p)$
\end{enumerate}

\item P would check that only orders which were double signed have a positive trading volume:
\begin{equation}
\forall o \in \text{[orders], vol}(o)>0 \implies \text{bitmap}(o) = 1 
\end{equation}
\item The equations \ref{limitprice_sat} and \ref{volume_balance} hold
\item For each trading pair, $P$ iterates through all orders and takes note of the highest limit price of an order having positive trading volume. 
It then loops through them again and checks that every other order with a lower limit price has been filled.
\end{enumerate}


\end{appendices}
\begin{thebibliography}{9}
\bibitem{DKG} 
Caimu Tang
\textit{ECDKG: A Distributed Key Generation Protocol Based on Elliptic
Curve Discrete Logarithm.}  
\href{https://pdfs.semanticscholar.org/3c52/35523be1d305de6dbf3433965c99d9fe4aea.pdf}{https://pdfs.semanticscholar.org/3c52/35523be1d305de6dbf3433965c99d9fe4aea.pdf}

\bibitem{priceOptimization} 
Gnosis
\textit{Multi-token Batch auctions with uniform clearning prices} \newline
 \href{https://github.com/gnosis/dex-research/tree/master/BatchAuctionOptimization}
{https://github.com/gnosis/dex-research/tree/master/BatchAuctionOptimization}
\bibitem{plasma} 
Vitalik Buterin and Joseph Poon
\textit{Plasma}.
 \href{https://plasma.io/plasma.pdf}
{https://plasma.io/plasma.pdf}
\bibitem{MVP} 
Vitalik Buterin
\textit{Plasma minimal viable product}
 \href{https://ethresear.ch/t/minimal-viable-plasma/426}
 {https://ethresear.ch/t/minimal-viable-plasma/426}
\bibitem{sig} 
Crypto aggregated signatures
\\\texttt{}
 \href{https://ethresear.ch/t/cryptoeconomic-signature-aggregation/1659}{https://ethresear.ch/t/cryptoeconomic-signature-aggregation/1659}

\bibitem{truebit}
True-bit games
 \href{https://truebit.io/}{https://truebit.io/}

\bibitem{snarks} 
Snarks using the library ZoKrates
 \href{https://github.com/JacobEberhardt/ZoKrates}{https://github.com/JacobEberhardt/ZoKrates}

\bibitem{ECIES} 
ECIES
\\\texttt{ECIES}
 \href{https://crypto.stackexchange.com/questions/31602/how-does-encryption-work-in-elliptic-curve-cryptography}{https://crypto.stackexchange.com/questions/31602/how-does-encryption-work-in-elliptic-curve-cryptography}

\bibitem{cipher} 
Knudsen-Nyberg cipher
\\\texttt{ Knudsen-Nyberg cipher}
 \href{https://eprint.iacr.org/2016/492.pdf}{https://eprint.iacr.org/2016/492.pdf}


\bibitem{batch} 
Batch Trading - \href{https://www.investopedia.com/terms/b/batchtrading.asp}{https://www.investopedia.com/terms/b/batchtrading.asp}

\bibitem{zokrates} Snarks - \href{https://github.com/JacobEberhardt/ZoKrates}{https://github.com/JacobEberhardt/ZoKrates}

\end{thebibliography}

\end{document}